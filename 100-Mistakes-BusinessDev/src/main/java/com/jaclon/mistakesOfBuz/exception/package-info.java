/**
 * 1. 不要在框架层面（比如AOP）做统一的异常处理，只建议在controller层做兜底工作（@RestControllerAdvice + @ExceptionHandler）
 * 对于自定义的业务异常，以 Warn 级别的日志记录异常以及当前 URL、执行方法等信息 后，提取异常中的错误码和消息等信息，转换为合适的 API 包装体返回给 API 调用方;
 * 对于无法处理的系统异常，以 Error 级别的日志记录异常和上下文信息(比如 URL、参 数、用户 ID)后，转换为普适的“服务器忙，请稍后再试”异常信息，同样以 API 包装 体返回给调用方。
 *
 * 除了通过日志正确记录异常原始信息外，通常还有 三种处理模式:
 * 转换，即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消 息，而不是随便抛一个无关或没有任何信息的异常，并最好通过 cause 关联老异常。
 * 重试，即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更严重，需要考虑当前情况是否适合重试。
 * 恢复，即尝试进行降级处理，或使用默认值来替代原始数据。
 *
 * 2.finally中的异常处理 使用 addSuppressed 方 法把 finally 中的异常附加到 try 中的异常上；
 * 对于实现了 AutoCloseable 接口的资源，建 议使用 try-with-resources 来释放资源
 *
 * 3.  确保正确处理了线程池中任务的异常，如果任务通过 execute 提交，那么出现异常 会导致线程退出，大量的异常会导致线程重复创建引起性能问题，
 * 我们应该尽可能确保任务 不出异常，同时设置默认的未捕获异常处理程序来兜底;
 * 如果任务通过 submit 提交意味着 我们关心任务的执行结果，应该通过拿到的 Future 调用其 get 方法来获得任务运行结果和 可能出现的异常，否则异常可能就被生吞了
 * @author jaclon
 * @since 2021/5/31 16:40
 */
package com.jaclon.mistakesOfBuz.exception;